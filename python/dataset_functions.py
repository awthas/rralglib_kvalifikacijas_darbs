import numpy as np
import pandas as pd


def read_file_csv_like(filepath, key_data=None, key_time=None, delimiter=None):
    """
    Generic function to read a .csv file with predefined keys
    """
    data_file = pd.read_csv(filepath, delimiter=delimiter, encoding="utf-8")

    if key_data is None:
        key_data = 1

    if key_time is None:
        key_time = 0

    key_time = data_file.keys()[key_time]
    key_data = data_file.keys()[key_data]

    time_raw = data_file[key_time]
    data_raw = data_file[key_data]

    data_raw = np.array(data_raw.tolist())
    time_raw = np.array(time_raw.tolist())

    return data_raw, time_raw
    
def read_file_csv_like_native(filepath, key_data=None, key_time=None, delimiter=None, start_index=None):
    """
    Generic function to read a .csv file with predefined keys implemented using native python file processing
    """

    if delimiter is None:
        delimiter = ","

    if key_data is None:
        key_data = 1

    if key_time is None:
        key_time = 0

    time_raw = []
    data_raw = []

    with open(filepath, "r", encoding="utf-8") as file:
        for i, line in enumerate(file):
            if i < start_index:
                continue
            try:
                line = line.split(delimiter)
                try:
                    time_raw.append(float(line[key_time]))
                except: 
                    ### Neulog style time column
                    time = line[key_time].split("'")[1].split(":")
                    time = float(time[0]) * 3600.0 + float(time[1]) * 60.0 + float(time[2])
                    time_raw.append(time)
                try:
                    data_raw.append(float(line[key_data]))
                except:
                    data_raw.append(float(line[key_data].split("\n")[0]))
            except:
                print("Couldn't parse line "+str(i)+"... "+str(line))

    data_raw = np.array(data_raw)
    time_raw = np.array(time_raw)

    return data_raw, time_raw

def read_file_bidmc(f, testfolder='../Elektrodu validÄcija_Anastasija'):
    """
    Reads the signal and breath annotation files of the specified BIDMC recording
    """

    alt_files = [2,5,11,18,19,23,24,27,39,42,44,46,50,52] # Files with out of order columns
    column_idxs = [3,1,2,2,1,3,2,1,2,2,2,2,2,2] # Correct column indices
    prefix = 'bidmc_'
    suffix_signals = '_Signals.csv'
    suffix_breaths = '_Breaths.csv'

    measkey = 1

    ### Choose the correct column
    for i in range(len(alt_files)):
        if alt_files[i] == f:
            measkey = column_idxs[i]
            break

    ### Create filename
    if f < 10:
        data_filename = prefix+"0"+str(f)+suffix_signals
        reference_filename = prefix+"0"+str(f)+suffix_breaths
    else:
        data_filename = prefix+str(f)+suffix_signals
        reference_filename = prefix+str(f)+suffix_breaths

    ### Read data
    data_file = pd.read_csv(testfolder+"/"+data_filename)
    reference_file = pd.read_csv(testfolder+"/"+reference_filename)

    key_time = data_file.keys()[0]
    key_meas = data_file.keys()[measkey]

    time_raw = data_file[key_time]
    data_raw = data_file[key_meas]

    data_raw = np.array(data_raw.tolist())
    time_raw = np.array(time_raw.tolist())

    ### Read reference data
    key_breath_1 = reference_file.keys()[0]
    key_breath_2 = reference_file.keys()[1]

    breaths_1 = reference_file[key_breath_1].fillna(0)
    breaths_2 = reference_file[key_breath_2].fillna(0)

    breaths_1 = np.array(breaths_1.tolist())
    breaths_1 = [int(b) for b in breaths_1]
    
    breaths_2 = np.array(breaths_2.tolist())
    breaths_2 = [int(b) for b in breaths_2]

    ### Pre-process data
    data = data_raw[:]

    return data, breaths_1, breaths_2

def read_file_gen2(filepath):
    """
    Reads the signal file of the specified GEN2 recording
    """
    fs_gen2 = 64

    data_file = pd.read_csv(filepath)

    key_time = data_file.keys()[0]
    key_meas = data_file.keys()[1]

    time_raw = data_file[key_time]
    data_raw = data_file[key_meas]

    data_raw = np.array(data_raw.tolist())
    time_raw = np.array(time_raw.tolist())

    data = data_raw[:]
    data_x = time_raw[:]

    return data, data_x

def read_file_rtor(filepath):
    data_file = pd.read_csv(filepath)

    key_time = data_file.keys()[1]
    key_meas = data_file.keys()[0]

    time_raw = data_file[key_time]
    data_raw = data_file[key_meas]

    data_raw = np.array(data_raw.tolist())
    time_raw = np.array(time_raw.tolist())

    data = data_raw[:]
    data_x = time_raw[:]

    return data, data_x

### type,dist,time
def read_file_gen2_peaks(filepath):
    """
    Reads the ESP32 results file generated by esp_gen2_tester.py
    """
    gen2_fs = 64.0

    data_file = pd.read_csv(filepath)

    key_type = data_file.keys()[0]
    key_dist = data_file.keys()[1]
    key_time = data_file.keys()[2]
    key_sqi = data_file.keys()[3]
    key_misc = data_file.keys()[4]

    type_raw = np.array(data_file[key_type].tolist())
    dist_raw = np.array(data_file[key_dist].tolist())
    time_raw = np.array(data_file[key_time].tolist())
    sqi_raw = np.array(data_file[key_sqi].tolist())
    misc_raw = np.array(data_file[key_misc].tolist())

    rr_data = np.zeros(np.count_nonzero(type_raw == 2))
    rr_time = np.zeros(np.count_nonzero(type_raw == 2))
    rr_sqi = np.zeros(np.count_nonzero(type_raw == 2))
    rr_misc = np.zeros(np.count_nonzero(type_raw == 2))
    hr_data = np.zeros(np.count_nonzero(type_raw == 1))
    hr_time = np.zeros(np.count_nonzero(type_raw == 1))
    hr_sqi = np.zeros(np.count_nonzero(type_raw == 1))
    hr_misc = np.zeros(np.count_nonzero(type_raw == 1))

    rridx, hridx = 0, 0
    for i in range(len(type_raw)):
        if type_raw[i] == 2:
            rr_data[rridx] = dist_raw[i]
            rr_time[rridx] = time_raw[i]/gen2_fs
            rr_sqi[rridx] = sqi_raw[i]
            rr_misc[rridx] = misc_raw[i]
            rridx += 1
        elif type_raw[i] == 1:
            hr_data[hridx] = dist_raw[i]
            hr_time[hridx] = time_raw[i]/gen2_fs
            hr_sqi[hridx] = sqi_raw[i]
            hr_misc[hridx] = misc_raw[i]
            hridx += 1

    return np.array([rr_data, rr_time, rr_sqi, rr_misc]), np.array([hr_data, hr_time, hr_sqi, hr_misc])

### type,rate,time,sqi
def read_file_gen2_rate(filepath):
    print("unimplemented")

def read_file_neulog(filepath, fs=None):
    if fs is None:
        fs = 10.0

    time_raw = []
    data_raw = []

    with open(filepath, "r", encoding="utf-8") as data_file:
        for i, line in enumerate(data_file):
            if i < 7:
                continue
            if len(line) < 2:
                break
            line = line.split("'")[1].split(";")
            time = line[0].split(":")
            time = float(time[0]) * 3600.0 + float(time[1]) * 60.0 + float(time[2])
            time_raw.append(time)
            data_raw.append(float(line[1]))

    neu_time = np.copy(time_raw)
    neu_data = np.copy(data_raw)

    return neu_data, neu_time

def f_score(tp, fp, fn): ### This might be better: https://ieeexplore.ieee.org/document/9941083
    """
    Calculate the generalized f-score
    """
    try:
        f = (2*tp)/(2*tp+fp+fn)
    except ZeroDivisionError:
        f = 0
    return f

def precision_score(tp, fp):
    """
    Calculate the precision metric
    """
    try:
        return tp/(tp+fp)
    except ZeroDivisionError:
        return -1
    
def recall_score(tp, fn):
    """
    Calculate the recall metric
    """
    try:
        return tp/(tp+fn)
    except ZeroDivisionError:
        return -1

def validate(pred, true, max_dist_samples=0, soft_margin_start=0, soft_margin_end=0):
    """
    Crosscheck algorithm results with ground-truth values
    """
    true_count = len(true)
    true_positives = 0
    false_positives = 0
    false_negatives = 0
    found = []
    
    for val in pred:
        correct = False
        for i, reference in enumerate(true):
            if val < reference+max_dist_samples and val > reference-max_dist_samples:
                if reference not in found:
                    correct = True
                    found.append(reference)
                break

        if correct:
            true_positives += 1
        else:
            false_positives += 1


    ### If a reference was not found, check if it falls within the soft margin before taking it into account for the true count
    for reference in true:
        if reference not in found:
            if reference < soft_margin_start or reference > soft_margin_end:
                true_count -= 1
    
    false_negatives = true_count-true_positives

    return true_positives, false_positives, false_negatives

def send_bytes(data, serial, debug=False, sample_size=2):
    if debug:
        print("\nSending "+str(len(data)*sample_size)+" bytes")

    clamp = False

    for i, val in enumerate(data):
        try:
            msg = int(val).to_bytes(sample_size, 'big', signed=True)
        except OverflowError:
            if not clamp:
                print("OverflowError: Press enter to proceed while clamping invalid values...")
                input()
                clamp = True
                if val > 0:
                    msg = int().to_bytes(2^(sample_size*8-1)-1, 'big', signed=True)
                else:
                    msg = int().to_bytes(-(2^(sample_size*8-1)), 'big', signed=True)
        serial.write(msg)
        if debug:
            print("Sent: "+str((i+1)*sample_size)+" bytes", end="\r")

    if debug:
        print("Sent: "+str((i+1)*sample_size)+" bytes")

def send_string(data, serial, debug=False):
    if debug:
        print("\nSending "+str(len(",".join(data)))+" bytes")

    count = 0
    for i, val in enumerate(data):
        msg = (str(val) + ',').encode("utf-8")
        serial.write(msg)
        count += len(msg)
        if debug:
            print("Sent: "+str(count)+" bytes", end="\r")

    if debug:
        print("Sent: "+str(count)+" bytes")
